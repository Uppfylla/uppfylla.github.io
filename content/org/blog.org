#+title: Blog
#+HUGO_BASE_DIR: ../content/english

* Blog
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_SECTION: blog
:EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
:END:
#+begin_src yaml :front_matter_extra t
meta_title: ""
description: "Blog posts."
#+end_src

* How to build static websites using org-mode, hugo and github actions.
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-build-with-hugo
:EXPORT_HUGO_SECTION: blog
:EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
:END:

#+begin_src yaml :front_matter_extra t
meta_title: "hugo website, org-mode in github actions."
description: "The post describes how to build a website using org-mode, applying theme using hugo and deploying to github pages. Using concept such as literate programming"
date: 2025-05-12
categories: ["Literate"]
author: "W L"
tags: ["hugo", "emacs", "org-mode", "github", "actions"]
draft: false
#+end_src

There’s no shortage of website building frameworks, however this post is for the stubborn and maybe the lazy—who'd like to write everything in =org-mode= and automate the rest. What follows is a practical (though not optimal) way of building a static website using Org-mode, Hugo, and GitHub Actions.

The goal with the post is just to demonstrate that it's possible to publish a website without leaving emacs, not to find an optimal way. 

We will explore the idea of using [[https://gohugo.io][hugo]] and =org-mode= to quickly build websites, and then deploy them to GitHub Pages using GitHub Actions.

** Assumptions

This guide assumes you’re familiar with Emacs, Git, and some basics of Hugo and GitHub Actions. It also assumes you’re comfortable installing dependencies. There are plenty of resources online to help you get started.

** Structure

There is, of course, not just one way to organize your project. However, here’s a structure that works well when integrating with Org-mode.

#+begin_src text
.
├── content
│   ├── config
│   │   └── _default
│   │       └── Your hugo configs goes here.
│   ├── hugo.toml ;; Your project specific configs
│   ├── org
│   │   ├── index.org
│   │   └── org files goes here.
│   └── themes
│       └── theme-name ;; As submodule.
├── LICENSE
└── README.org ;; Imagine using markdown ;)
#+end_src

Follow your theme’s instructions for setup. As long as you place your =.org= content in the =org= directory, you’ll be able to export everything you need.

** Hugo

Start by picking a theme, for example by exploring https://themes.gohugo.io. 

Unless you plan to modify the template, adding the theme as a submodule is recommended.

#+begin_src shell
git submodule add -b main https://<THEME_URL>.git themes/<THEME_NAME>
#+end_src

Next, configure =content/hugo.toml=:

#+begin_src toml
languageCode = 'en-us'
title = 'demo'
theme = "archie" # For example
#+end_src

Theme-specific options often live in =./content/config/_default/=. You can edit for example params:

#+begin_src toml
# ./content/config/_default/params.toml
# These params might be generic or theme specific.
favicon = "images/favicon.png"
#..
#..
# E.g. theme specific Announcement
# https://github.com/gethugothemes/hugo-modules/tree/master/components/announcement
[announcement]
enable = true
expire_days = 7
content = "The grass is not greener on the other side."
#+end_src

*** How to build ?

There are multiple ways to build a Hugo site. The simplest is using the Hugo CLI: https://gohugo.io/commands/hugo_build/. We’ll also look at how to build and deploy with GitHub Actions.

** Org-mode

Now that we’ve set up and tweaked the site, let’s start adding content.

*** Prerequisites

+ [[https://ox-hugo.scripter.co/][ox-hugo]] – exports Org to Hugo-flavored Markdown  
+ [[https://orgmode.org/][org-mode]] – the mode 

*** Exporting content

Here’s how to create the homepage with a =_index.md=:

#+begin_src org
#+title: Index
#+HUGO_BASE_DIR: ../content/
#+HUGO_SECTION: /
#+EXPORT_FILE_NAME: _index

Recognize untruth as a condition of life...
#+end_src

Export using Emacs:

#+begin_src emacs-lisp :results none
(org-hugo-export-wim-to-md t)
#+end_src


This will create =./content/content/_index.md=. Yes, the naming should maybe be reconsidered, but it works for our demonstration.

*** Custom Front Matter

Need theme-specific front matter (e.g., YAML)? You can use the =hugo_front_matter_format:= property:

#+begin_src emacs-lisp
#+title: Index
#+HUGO_BASE_DIR: ../content/english
#+HUGO_SECTION: /
#+EXPORT_FILE_NAME: _index
#+hugo_front_matter_format: yaml
\\#+begin_src yaml :front_matter_extra t
banner:
  title: "Demo"
  button:
    enable: true
\\#+end_src
#+end_src

** Automating with GitHub Pages

*** Step 1: Checkout Repo and Setup GitHub Pages

#+begin_src yaml
name: Publish Changes
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
env:
  HUGO_ENV: production
  GO_VERSION: "1.23.3"
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5
#+end_src

*** Step 2: Export Org Files on the Runner

We clone the necessary Emacs packages and run Emacs in batch mode.

#+begin_src yaml
- name: Clone dependencies
  run: |
    git clone https://github.com/kaushalmodi/ox-hugo.git ox-hugo
    git clone https://github.com/kaushalmodi/tomelr tomelr
- name: Setup emacs
  uses: purcell/setup-emacs@master
  with:
    version: 28.2
- name: Export Org file to Markdown
  run: |
    yes | emacs ./content/org/index.org --batch -L $(pwd)/tomelr -L $(pwd)/ox-hugo -l $(pwd)/ox-hugo/ox-hugo.el --eval='(org-hugo-export-wim-to-md t)' --kill
#+end_src

Want to process all =.org= files?

#+begin_src shell
- name: Export Org files to Markdown
        run: for f in ./content/org/*.org; do emacs "$f" --batch -L "$(pwd)/tomelr" -L "$(pwd)/ox-hugo" -l "$(pwd)/ox-hugo/ox-hugo.el" --eval='(org-hugo-export-wim-to-md t)' --kill; done
#+end_src

*** Step 3: Run Hugo

A standard Hugo build step:

#+name: setup
#+begin_src yaml
- name: Setup Hugo
  uses: peaceiris/actions-hugo@v3
  with:
    hugo-version: '0.125.0'
    extended: true
#+end_src

#+name: build
#+begin_src yaml
- name: Build with Hugo
  working-directory: ./content
  env:
    HUGO_ENVIRONMENT: production
    HUGO_ENV: production
  run: |
    hugo \
      --minify \
      --baseURL "${{ steps.pages.outputs.base_url }}/"
#+end_src

Alternative with npm:

#+begin_src yaml
- name: Setup Hugo
  uses: peaceiris/actions-hugo@v3
  with:
    hugo-version: '0.141.0'
    extended: true
- name: Install Go
  run: |
    wget -O ${{ runner.temp }}/go.deb https://dl.google.com/go/go${GO_VERSION}.linux-amd64.tar.gz \
    && sudo tar -C /usr/local -xzf ${{ runner.temp }}/go.deb
- name: Install npm dependencies
  run: npm --prefix ./content install
- name: Build site
  run: npm --prefix ./content run build
#+end_src

*** Step 4: Upload and Deploy to GitHub Pages

#+name: Artifact
#+begin_src yaml
- name: Upload artifact
  id: upload-artifact
  uses: actions/upload-pages-artifact@v3
  with:
    path: ./content/public
#+end_src

#+name: deploy
#+begin_src yaml
deploy:
  if: ${{ github.event_name == 'push' }}
  needs: build
  permissions:
    pages: write
    id-token: write
  environment:
    name: github-pages
    url: ${{ steps.deployment.outputs.page_url }}
  runs-on: ubuntu-latest
  steps:
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
#+end_src

** Closing Thoughts

This setup isn't the most minimal nor optimal, but it works quite well. You have the ability to write your entire website in Org-mode, export it using =ox-hugo=, and deploy everything with a single push to GitHub.

The approach is (for me) quite enjoyable, as once setup, I can quickly add an entry to the website without leaving emacs.

If you're allergic to clicking through CMS dashboards and want to spend time writing content, this method might be something for you.


The grass isn't greener - the weeds just grow differently. Choose the problems you enjoy solving.
* Linking Zig libraries to other languages
:PROPERTIES:
:EXPORT_FILE_NAME: zig-static-dynamic-linking
:EXPORT_HUGO_SECTION: blog
:EXPORT_HUGO_FRONT_MATTER_FORMAT: yaml
:END:

#+begin_src yaml :front_matter_extra t
meta_title: "Linking with zig."
description: "The post describes how to link static and dynamic zig libraries with examples for rust and python."
date: 2025-05-18
categories: ["Zig"]
author: "W L"
tags: ["zig", "linking"]
draft: true
#+end_src

Creating cross language libraries can be powerful technique, though not always beneficial. Hypothetically, if you've written a high performance library in Zig but the customer request usage of another programming language. You may still reuse your Zig performance and the build system enables you to do this (quite) smoothly...

In this guide, we'll explore Zig's build system and it's interoperability capabilities to make cross-language library straightforward. We'll build a complete example that demonstrates both static and dynamic linking approaches, giving you the foundation to create your own cross-language libraries.

Full example can be found at [[https://github.com/Uppfylla/uppfylla.github.io/tree/main/content/examples/zig/linking][github]].

** References
+ [[https://github.com/tigerbeetle/tigerbeetle][Tigerbeetle]] - Great project and development philosophy, please have a look.
+ [[https://www.youtube.com/watch?v=PgulOEQXB9E][Zig in depth]] - Great tutorial series , please go give "Dude the Builder" some support.
+ [[https://ziglang.org/documentation/0.14.1/#Exporting-a-C-Library][Zig Documentation]] - Obviously z
** Environment

#+name: Zig version
#+begin_src shell
zig version
#+end_src

#+RESULTS: Zig version
: 0.14.0

This tutorial targets Zig =0.14.0=, while newer versions may work, pinning to a specific version ensures our examples remain accurate and functional.

** Goal

Our goal is to demonstrate how linking work in practice using Zig. We'll create a simple function in Zig and then show how to consume it from different programming languages.

Without too much thought, we'll build a Python client that uses dynamic linking and a Rust client that uses static linking. With the purpose to help you understand each strategies benefits and drawbacks.

*Why This Matters*:  Static linking creates self-contained applications that are easy to deploy but potentially larger in size. Dynamic linking enables code sharing and updates but requires careful dependency management. Linking strategies are important strategies to build robust software systems. However, it can be tricky and not always applicable to your usecase so please carefully consider the advantages before diving into this rabbit hole.

** Function to export

Let's consider the library to export, it contains one simple =add= function that we'll aim to export to other programming languages. It's not too exciting but the key insight here is that for a function to be callable from other languages using , it must be compatible with the C Application Binary Interface (ABI) which is achieved in Zig by utilizing the export keyword or =@export= builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible meaning that virtually most programming languages can interpret.

#+name: root.zig
#+begin_src zig :tangle ../examples/zig/linking/src/root.zig
// Tangled from content/org/blog.org
const std = @import("std"); // Importing standard lib
const builtin = @import("builtin"); // Builtins

comptime { // Run this at compile time.
    if (!builtin.link_libc) { // Require libc
        @compileError("Symbols cannot be exported without libc.");
    }
    // Creates a symbol in the output object file which refers to the target of add function. Essentially this is equivalent to the export keyword used on a function.
    @export(&add, .{ .name = "zig_add", .linkage = .strong });
}

// Our add function with C calling conventions, ensuring our function can be called correctly from other languages.
pub fn add(a: i32, b: i32) callconv(.C) i32 {
    return a + b;
}
#+end_src

** Build system
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/build.zig" :noweb tangle
:END:

Zig's build system is powerful, enabling us to create complex, multi-target builds with clean, readable configuration. In this sub-chapter we'll breakdown how to structure the build file with the purpose of linking.

*** Platform and Architecture Configuration

Before diving into the build logic, we need to understand how Zig handles cross-compilation. One of Zig's standout features is its ability to compile for virtually any target platform.

In this example we'll use the following; it's possible that you might have to change these in order to match your system.

#+name: arch-os-abi
#+begin_src zig :tangle no
"x86_64-linux-gnu.2.27"
#+end_src

#+name: arch-os
#+begin_src zig :tangle no
"x86_64-linux"
#+end_src

Target specification for the binary. It specifies the CPU architecture (x86_64), operating system (Linux), ABI (GNU), and minimum gnu (glibc) version (2.27).

#+name: cpu-features
#+begin_src zig :tangle no
"x86_64_v3+aes"
#+end_src

The CPU features specification enables processor-specific optimizations. The "x86_64_v3" designation refers to a specific microarchitecture level, while "+aes" enables AES instruction set extensions. These optimizations can significantly improve performance for compute-intensive operations.

*** Imports

Essential imports:

#+name: imports
#+begin_src zig
const std = @import("std"); //  Zig's standard library
const assert = std.debug.assert; // Assert!
const builtin = @import("builtin"); // Builtins
const log = std.log.scoped(.build_log); // Scoped log, not 100% necessary in this example but we believe that it's a good practice.
#+end_src

*** Zig Version Compatibility

#+name: Version
#+begin_src zig
comptime {
    const zigv_comp = builtin.zig_version.major == 0 and
        builtin.zig_version.minor == 14 and
        builtin.zig_version.patch == 0;
    if (!zigv_comp) {
        @compileError(std.fmt.comptimePrint("Zig version unsupported found {} expected 0.14.0", .{ builtin.zig_version },));
    }
}
#+end_src

Do compatibility check at compile-time to avoid possibly confusing runtime errors and making it immediately clear what needs to be fixed.

This could ofcourse be done in different ways, we could also use ~std.SemanticVersion~ but for the sake of the demo we'd like to keep it simple.

#+begin_src zig :tangle no
const zversion = std.SemanticVersion{
    .major = 0,
    .minor = 14,
    .patch = 0,
};
#+end_src

*Why Version Checking Matters*: Zig is still evolving rapidly, by enforcing a specific version requirement, we ensure our build scripts work reliably and provide clear error messages when developers use incompatible versions.

*** Building library functionality

#+name: Building lib function
#+begin_src zig
fn build_lib(
    b: *std.Build,
    steps: *std.Build.Step,
    options: struct {
        optimize: std.builtin.OptimizeMode,
    },
) void{


    const query = std.Target.Query.parse(.{
            .arch_os_abi = <<arch-os-abi>>,
            .cpu_features = <<cpu-features>>,
    }) catch unreachable;
    const resolved_target = b.resolveTargetQuery(query);

    //const shared_lib = b.addSharedLibrary(.{
    //    .name = "lib",
    //    .root_source_file = b.path("src/root.zig"),
    //    .target = options.target,
    //    .optimize = options.optimize,
    //});

    //shared_lib.linkLibC();

    //const static_lib = b.addStaticLibrary(.{
    //    .name = "lib",
    //    .root_source_file = b.path("src/root.zig"),
    //    .target = options.target,
    //    .optimize = options.optimize,
    //});

    //static_lib.pie = true;
    //static_lib.bundle_compiler_rt = true;
    //static_lib.linkLibC();

    const shared = b.addSharedLibrary(.{
            .name = "add",
            .root_source_file = b.path("src/root.zig"),
            .target = resolved_target,
            .optimize = options.optimize,
    });
    shared.linkLibC();
    log.info("Creating shared lib {s}", .{
        b.pathJoin(&.{
            "./src/clients/lib/",
            <<arch-os-abi>>,
            shared.out_filename,
            })});
    steps.dependOn(&b.addInstallFile(
            shared.getEmittedBin(),
            b.pathJoin(&.{
            "../src/clients/lib/",
            <<arch-os-abi>>,
            shared.out_filename,
            }),
    ).step);

    const static = b.addStaticLibrary(.{
            .name = "add",
            .root_source_file = b.path("src/root.zig"),
            .target = resolved_target,
            .optimize = options.optimize,
    });

    static.pie = true;
    static.bundle_compiler_rt = true;
    static.linkLibC();
    log.info("Creating static lib {s}", .{
        b.pathJoin(&.{
            "./src/clients/lib/",
            <<arch-os-abi>>,
            static.out_filename,
            })});
    steps.dependOn(&b.addInstallFile(
            static.getEmittedBin(),
            b.pathJoin(&.{
            "../src/clients/lib/",
            <<arch-os-abi>>,
            static.out_filename,
            }),
    ).step);

    // In case we'd like to add a module to the lib, we could do for example;
    //const util_mod = b.createModule(.{ .root_source_file = b.path("src/lib/util.zig") });
    //lib.root_module.addImport("util", util_mod);


    // Specify path to link libs..

    //step.dependOn(&lib.step);
    //return lib;
}
#+end_src

*Understanding the Build Function*: Here we creating a static library from =root.zig=.
+ ~std.Build~ - type contains the information used by the build runner.
+ ~std.Build.Step~ - a "step" of our build process with it's own dependencies that need to finish before this step.
+ ~options~ - struct parameter pattern provides clean, typed configuration options. We'll tend to follow this pattern throughout the article.
  + ~std.Build.ResolvedTarget~ - Resolved target to build, used for cross-compilation.
  + ~std.builtin.OptimizeMode~ - Optimization configurations.

*** Building Python client

#+name: py-bindings-destination
#+begin_src zig :tangle no
"./src/clients/python/src/bindings.py"
#+end_src


Building libraries for Python consumption involves some interesting challenges. Python's dynamic nature and C extension API require careful attention to memory management, error handling, and type conversion.

#+name: Building python client
#+begin_src zig
fn build_python_client(b: *std.Build, steps: *std.Build.Step) void {
#+end_src

*Python Binding Generation*: The approach we'll take involves automatically generating Python binding code at build time. This ensures consistency between our Zig API and the Python interface while reducing overhead with manual maintenance.

#+name: Store py info
#+begin_src zig :noweb yes
const PythonBuildStep = struct {
    source: std.Build.LazyPath,
    step: std.Build.Step,

    // Ofcourse this could become more generic..
    fn make_python(step: *std.Build.Step, prog_node: std.Build.Step.MakeOptions) anyerror!void {
            _ = prog_node; // Not needed in this example..
            const _b = step.owner;
            const py: *@This() = @fieldParentPtr("step", step);
            const source_path = py.source.getPath2(_b, step);
            const p = try std.fs.Dir.updateFile(
                    _b.build_root.handle,
                    source_path,
                    _b.build_root.handle,
                    <<py-bindings-destination>>,
                    .{},);
            step.result_cached = p == .fresh;
    }

    pub fn init(_b: *std.Build) *@This() {
        const build_step = _b.allocator.create(@This()) catch @panic("Out of memory!");
        build_step.* = .{
                .source = _b.addRunArtifact(_b.addExecutable(.{
                .name = "python_bindings",
                .root_source_file = _b.path("src/clients/python/bindings.zig"),
                .target = _b.graph.host,
        })).captureStdOut(),
                .step = std.Build.Step.init(.{ // Initialize a build step.
                        .id = .custom,
                        .name = _b.fmt("generate {s}", .{std.fs.path.basename(<<py-bindings-destination>>)}),
                        .owner = _b,
                        .makeFn = make_python, // This could ofcourse be more elegant, e.g. have a struct for all generated code with member functions...
                }),
        };

        build_step.source.addStepDependencies(&build_step.step);
        return build_step;
    }
};
#+end_src
*Custom Build Steps Explained:* The PythonBuildStep structure manages the process of running a Zig function to generate Python bindings, capturing its output, and writing it to the appropriate file.

The make_python function handles the actual file generation which is called during the Step, while the init function sets up the build step dependencies. We've structured it this way in order to keep persistent data such as ~step~ in the steps make function.

**** Creating our build query

#+begin_src zig :noweb yes
        const bindings = PythonBuildStep.init(
                b,
        );

        steps.dependOn(&bindings.step);
#+end_src

*Dynamic Library Configuration*: This section creates a shared library (.so file in our case) that Python can load at runtime. The linkLibC() call is essential for C ABI compatibility, enabling Python's ctypes module to call our functions correctly.

#+name: Close python build function bracket
#+begin_src zig
}
#+end_src


**** Python example usage
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/src/clients/python/src/example.py" :noweb tangle
:END:
#+begin_src python
from lib import lib
a = 1
b = 2
for i in range(10):
    print(f"Calling add ({a*i}+{b*i}) from python {lib.zig_add(a*i,b*i)}")
#+end_src
*Integration Simplicity*: Notice how clean the Python interface is. The complexity of cross-language binding is hidden behind a simple function call. The Python developer doesn't need to understand Zig internals or memory management details just call our API.

**** Python bindings
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/src/clients/python/bindings.zig" :noweb tangle
:END:

Creating python bindings zig in a separate file, =src/clients/python/bindings.zig=, props to [[https://github.com/tigerbeetle/tigerbeetle/tree/main/src/clients][tigerbeetle clients]]


#+begin_src zig
const std = @import("std");
const root = @import("root");

const Buffer = struct {
    inner: std.ArrayList(u8),

    pub fn init(allocator: std.mem.Allocator) Buffer {
        return .{
            .inner = std.ArrayList(u8).init(allocator),
        };
    }

    pub fn write(self: *Buffer, comptime format: []const u8, args: anytype) void {
        self.inner.writer().print(format, args) catch unreachable;
    }
};

pub fn main() !void {
    @setEvalBranchQuota(100_000);
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const alloc = arena.allocator();
    var buffer = Buffer.init(alloc);
    buffer.write(
        \\##########################################################
        \\##       !!! WARNING, DO NOT EDIT THIS FILE !!!         ##
        \\##         Auto-generated file python bindings.         ##
        \\##########################################################
        \\from .lib import lib # Amazing naming creativity..
        \\zig_add = lib.zig_add
    , .{});
    try std.io.getStdOut().writeAll(buffer.inner.items);
}
#+end_src

The ~@setEvalBranchQuota~  changes the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error.

It's not 100% necessary in this example, however it becomes relevant in case we're looking to expand our API.

***** Python Lib
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/src/clients/python/src/lib.py" :noweb tangle
:END:


#+name: Python lib
#+begin_src python
from ctypes import CDLL
from pathlib import Path
def _load_lib():
    """ Loads the library, assumes the host machine plattform. """
    path = Path(__file__).parent.parent.parent / "lib" / "x86_64-linux-gnu.2.27/libadd.so"
    return CDLL(str(path))

lib = _load_lib()
#+end_src

We can now load and expose our library to python.


*** Building Rust client

#+name: rust-lib-destination
#+begin_src zig :tangle no
"./src/clients/rust/src/lib.rs"
#+end_src

This sub-chapter is essentially the same as building our python client .. we'll describe less .. [TODO]

#+name: Building rust client
#+begin_src zig
fn build_rust_client(b: *std.Build, steps: *std.Build.Step ) void {
#+end_src


Recreating the buildstep struct for Rust, which could be made generic as the content doesn't change too much. However, I'm under the impression that it would introduce additional complexity and make it more difficult to understand. Thus, for the sake of this guide, we'll keep them separated.


#+name: Store rust info
#+begin_src zig :noweb yes
const RustBuildStep = struct {
    source: std.Build.LazyPath,
    step: std.Build.Step,

    // Ofcourse this could become more generic..
    fn make_rust(step: *std.Build.Step, prog_node: std.Build.Step.MakeOptions) anyerror!void {
            _ = prog_node; // Not needed in this example..
            const _b = step.owner;
            const py: *@This() = @fieldParentPtr("step", step);
            const source_path = py.source.getPath2(_b, step);
            const p = try std.fs.Dir.updateFile(
                    _b.build_root.handle,
                    source_path,
                    _b.build_root.handle,
                    <<rust-lib-destination>>,
                    .{},);
            step.result_cached = p == .fresh;
    }

    pub fn init(_b: *std.Build) *@This() {
        const build_step = _b.allocator.create(@This()) catch @panic("Out of memory!");
        build_step.* = .{
                .source = _b.addRunArtifact(_b.addExecutable(.{
                .name = "rust_bindings",
                .root_source_file = _b.path("src/clients/rust/bindings.zig"),
                .target = _b.graph.host,
        })).captureStdOut(),
                .step = std.Build.Step.init(.{ // Initialize a build step.
                        .id = .custom,
                        .name = _b.fmt("Generate rust : {s}", .{std.fs.path.basename(<<rust-lib-destination>>)}),
                        .owner = _b,
                        .makeFn = make_rust, // This could ofcourse be more elegant, e.g. have a struct for all generated code with member functions...
                }),
        };
        build_step.source.addStepDependencies(&build_step.step);
        return build_step;
    }
};
#+end_src


We don't need to call link ..

#+begin_src zig :noweb yes
        const bindings = RustBuildStep.init(
                b,
        );
        steps.dependOn(&bindings.step);
#+end_src



#+name: Close rust client
#+begin_src zig
}
#+end_src

**** Rust bindings
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/src/clients/rust/bindings.zig" :noweb tangle
:END:

Creating rust bindings zig in a separate file, =src/clients/rust/bindings.zig=, props to [[https://github.com/tigerbeetle/tigerbeetle/tree/main/src/clients][tigerbeetle clients]]


#+begin_src zig
const std = @import("std");
const root = @import("root");

const Buffer = struct {
    inner: std.ArrayList(u8),

    pub fn init(allocator: std.mem.Allocator) Buffer {
        return .{
            .inner = std.ArrayList(u8).init(allocator),
        };
    }

    pub fn write(self: *Buffer, comptime format: []const u8, args: anytype) void {
        self.inner.writer().print(format, args) catch unreachable;
    }
};

pub fn main() !void {
    @setEvalBranchQuota(100_000);
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const alloc = arena.allocator();
    var buffer = Buffer.init(alloc);
    buffer.write(
        \\// !!! WARNING, DO NOT EDIT THIS FILE !!!
        \\// Auto-generated file python bindings.
        \\pub mod zig {{
        \\   extern "C" {{
        \\       pub fn zig_add(a: i32, b: i32) -> i32;
        \\   }}
        \\}}
    , .{});
    try std.io.getStdOut().writeAll(buffer.inner.items);
}
#+end_src

The ~@setEvalBranchQuota~  changes the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error.

It's not 100% necessary in this example, however it becomes relevant in case we're looking to expand our API.

**** Rust example usage
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/src/clients/rust/src/main.rs" :noweb tangle
:END:
In order to call external functions we need to use unsafe, please have a look at [[https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html][the rust documentation.]]
#+begin_src rust
use example::zig::zig_add as add;

fn main() {
    println!("Example!");
    for n in 1..101 {
        unsafe {
                println!("Using zig add: {:?}", add(1*n, 2*n));
        }
    }
}
#+end_src

**** Cargo
:PROPERTIES:
:header-args: :comments no :mkdirp yes :tangle "../examples/zig/linking/src/clients/rust/Cargo.toml" :noweb tangle
:END:

Let's add a cargo file for easier testing.
#+begin_src toml
[package]
name = "example"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

In `examples/zig/linking/src/clients/rust`
#+begin_src shell :results no :tangle no
cargo run --release
#+end_src


*** Build function

#+name: Define build function
#+begin_src zig
pub fn build(b: *std.Build) !void {
#+end_src


The main build function orchestrates the entire compilation process, managing dependencies and configuring different build targets:

**** Steps

This is not too exciting, provide clear entry points for different build targets.
+ Build library
+ Build Rust client
+ Build Python client

This organization makes it easy for developers to build only what they need and understand what each build target produces.

#+begin_src zig 
        const steps = .{
                .build_lib = b.step("lib", "Builds the library."),
                .rust_client = b.step("clients:rust", "Builds Rust Client with lib"),
                .python_client = b.step("clients:python", "Builds Python Client with lib"),
        };
#+end_src

**** Optimizations

Even though we don't necessarily need this in the example, let's optimize for release.

#+name: Optimize
#+begin_src zig
        const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseSafe });
#+end_src

The =ReleaseSafe= optimization mode provides performance optimizations while retaining safety checks.

***** Building our library
#+name: Build lib
#+begin_src zig
        build_lib(b, steps.build_lib, .{
                .optimize = optimize,
        });
#+end_src
This demonstrates how our modular build functions integrate with the main build process and is accessible with our  =build:lib= option.  The unused variable assignment shows how you might reference the library for additional processing.

#+begin_src shell :tangle no :results none
zig build lib
#+end_src

Now to build a specific language client with the library
#+begin_src zig
        // E.g. python client
        build_python_client(b, steps.python_client);
#+end_src

*Client Build Execution*: The Python client build demonstrates how different language integrations can be managed within the same build system. Each client type can have its own build logic while sharing common library components.

For example;

#+begin_src shell :tangle no :results none
zig build clients:python
#+end_src

Then run
#+begin_src shell :tangle no
python3 src/clients/python/src/example.py
#+end_src

And ofcourse the same goes for building rust client

#+begin_src zig
        // E.g. rust client
        build_rust_client(b, steps.rust_client);
#+end_src

For example;

#+begin_src shell :tangle no :results none
zig build clients:rust
#+end_src

Don't forget to let rust know where to the static library is located.

#+begin_src shell :tangle no
cd src/clients/rust
RUSTFLAGS="-L ../lib/x86_64-linux-gnu.2.27" cargo run
#+end_src

**** Close build function
#+name: Close build function
#+begin_src zig
}
#+end_src


** Usage

#+begin_src shell
Usage: zig build [steps] [options]

Steps:
  install (default)            Copy build artifacts to prefix path
  uninstall                    Remove build artifacts from prefix path
  lib                          Builds the library.
  clients:rust                 Builds Rust Client with lib
  clients:python               Builds Python Client with lib
#+end_src

** Key concepts (TODO)
+ Understanding Linking Strategies
+ Memory Management Across Language Boundaries
+ Error Handling Translation
+ Performance Considerations
+ Testing Strategies

This comprehensive approach to cross-language library development with Zig provides a solid foundation for building efficient, maintainable systems that leverage the "best" (󰱸) of multiple programming languages. The combination of Zig's performance, safety, and excellent interoperability makes it an good alternative to more common approaches such as C for creating libraries that need to work across language boundaries...
